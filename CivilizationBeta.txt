Имаме играчи, всеки играч притежава държава, състояща се от градове и единици(бойни и цивилни). 
Територията на държавата се определя от културата на градовете, колкото повече култура има един град, 
на толкова повече територия оказва влияние и съответно толкова по-големи са границите на държавата.
Всеки град принадлежащ на държавата има име и националност (държавата към която принадлежи) 
Националността може да се сменя, ако градът бъде завладян от друга националност (на противников играч). 
Градовете имат население, чийто брой определя колко земи около града се обработват, като всяка земя 
която се обработва носи някакви дивиденти на града.

Какви дивиденти може да получи даден град от обработвана земя или сгради?
Точки производство (чукчета)
Точки храна (класове пшеница)
Точки наука (епруветки)
Точки култура (нотички)

Всеки град може да избере с какво да се занимава в даден период от време.
Създава единици (бойни или цивилни) 
Строи сгради, които носят дивиденти
Бързината с която се случват тези две неща в даден град зависи от броя точки “производство”
Сградите - всяка от тях носи дивиденти във вид на някакви точки.

Точките са от точно един вид и може въпросния бонус да се дава на един от двата принципа:
Фиксиран брой точки
Процент от броя на натрупаните до момента фиксирани точки
Единиците - два основни типа единици:
Цивилни, отговарят за основаването на нови градове и усвояването на прилежащите им територии.
Бойни, отговарят за защита на градовете и цивилните единици, както и за унищожението на единиците 
на противника и завладяването на градовете му.

Играта ще е походова, т.е. ако допуснем че се играе от двама и повече играчи и всеки е на отделна нишка, 
shared resource ще са картата на която се случват нещата и чатът, който ще могат да водят помежду си. 
Ходовете на всички играчи ще се извършват успоредно на картата, като в момента в който играч приключи ход № n, 
за да премине към ход № n+1 трябва да изчака всички останали да са приключили ход № n. 
Битките между единиците на играчите ще се случват автоматично, когато даден играч постави единица на поле 
на което се намира единица на противников играч. 
Цивилните единици няма да могат да атакуват, т.е. няма да могат да бъдат поставяни на поле, 
на което се намира единица на противников играч.


Задача 1. Тази задача ще създава необходимите базови абстракции за играта, която ще напишем. 
Ще създадем можещи и неможещи да мърдат единици в играта, 
както и конкретна такава единица - Заселници (Settlers) способна да създава нови населени места (City)

Да се напише abstract class GameUnit който да има координати в равнината х и у. И булево поле дали е селектиран.
Да се напишат гетъри за всички полета и сетър за полето, което показва дали текущия обект е селектиран, 
както и конструктор с аргументи координатите на единицата. 
В този конструктор стойността на полето, което показва дали единицата е селектирана да е false.
Да се override-не методът toString() така че да връща “u” ако единицата не е селектирана и “U” ако е селектирана.
Да се напише булев метод isMoveable(), който да връща стойност false.

Да се напише abstract class MoveableUnit който да наследява GameUnit, този клас да създава сетъри за 
координатите на текущия обект. 
Да се override-не метода isMoveable() така че да връща стойност true.
Да се напишат методи за мърдане на единицата, наляво, надясно, нагоре и надолу, както и по-диагонал. 
Общо трябва да са 8 метода. Изберете подходящи имена за методите. Не забравяйте, че една единица може 
да се мърда само ако е селектирана.

Да се напишат абстрактни методи:
void buildField()
void buildMine()
void buildRoad()
void buildCity()

Да се напише class SettlersUnit който да наследява MoveableUnit. Да се имплементират наследените методи, 
така че всички освен този за строеж на град, да изкарват съобщение че това действие е невалидно. 
А този за строеж на град засега да остане празен.


Задача 2. Решавайки тази задача, ще надградим кода, така че да може заселниците да строят град и всички единици,
които са “мърдащи” да могат да извършват мърдане чрез текстови команди. 

Да се напише клас City, който да наследява GameUnit. Класът да има поле за име на града, което да е immutable. 
Класът да има конструктор с аргументи, които да са име на града и координатите му на картата. 
Да се override-не toString() така че да връща “С” когато обектът е селектиран и “с” в противен случай.

Да се напише клас Game, който да има следните статични полета:
брой редове на картата за игра
брой колони на картата за игра
последният селектиран GameUnit
списък на всички GameUnit-и в играта

Класът да има следните статични методи:
addGameUnit(GameUnit unit) - добавя единица към играта

removeGameUnit(GameUnit unit) - премахва единица от играта (необходим е когато някоя единица бъде унищожена 
от единица на противника или когато заселниците построят град)

printMap() - изкарва на стандартния изход картата с всички единици на нея. Да си личи коя единица е селектирана,
ако има селектирана разбира се.

play() - слуша за следните команди:

select row column - селектира единица намираща се на тези координати на картата. Ако няма единица, която да бъде
селектирана извежда съобщение за грешка.

move (left, right, up, down, up-left, up-right, down-left, down-right) премества селектираната единица 
в съответната посока. Ако селектираната единица не може да бъде преместена изкарва съобщение за грешка

build city - ако селектираната единица има правото да строи град се пита за името на града и се строи град, 
в противен случай се извежда съобщение за грешка.

Задача 3. 

За да може всеки един град в играта да произвежда продукция (нови мърдащи единици или пък сгради, които да се 
строят в града) трябва да добавим нови неща в нашия код. Ход ще наричаме действията, които единиците ни могат да
извършат преди да се “уморят” и да не могат да извършват нищо повече. Например в рамките на един ход нашите
мърдащи единици могат да мръднат веднъж на съседно поле, след това се изморяват и спират да могат да мърдат,
докато тече този ход. На следващия ход силите им се възстановяват и те отново могат да се движат, но отново само
с едно поле, до някое от съседните си. Производството в градовете ни ще се случва по следния начин. 
Градът има точки за производство, които се дават на всеки ход. Градът знае колко точки производство е събрал до
момента и какво му е сетнато да произвежда. В момента, в който точките производство, които е събрал градът
станат равни на или повече от точките, необходими за производството на единицата, която е в процес единицата 
е готова. Ако тя е мърдаща, то се появява вдясно на града, ако е сграда се “строи” в самия град и не се отразява 
на картата.

В класа GameUnit ще добавим поле productionPoints което ще е от тип int и ще определя колко производствени точки
са ни необходими за да построим дадената единица. Нека в класа създадем също така и гетър и сетър за полето. 
Нека в класа да добавим и булев метод isCity(), който да връща стойност false.

В класа MoveableUnit ще добавим булево поле moved, което ще пази дали даденият обект вече е извършил хода си. 
Добавяме сетър и гетър за полето. Освен това модифицираме полето ако за обекта извикаме някой от move методите.

В класа City override-ваме метода isCity() така че да връща true. Освен това добавяме полета productionPerTurn, 
productionInProgress и inProduction, първите две от които са от тип int и в конструктора им даваме стойности 
съответно 1 и 0, а последното е от тип GameUnit и в конструктора го сетваме да е нов SettlersUnit обект. 
Създаваме метод incrementProductionInProgress който да увеличава стойността productionInProgress с 
productionPerTurn, като ако стойността достигне или надхвърли productionPoints на GameUnit-а който се 
строи в момента, той трябва да се материализира на картата, вдясно от града, който го е построил.

В класа Game трябва да добавим код, с помощта на който да се разпознава командата end turn. Тя трябва да сетва 
стойност false за moved полето на всички moveable обекти. Освен това за всички градове трябва да се вика 
incrementProductionInProgress метода.

За тестване можете да сетнете в конструктора на City inProgress да е SettlersUnit а в класа SettlersUnit 
productionPoints да са 2, за да може бързо да се създават нови единици от този тип.  


Задача 4.

Сигурно сте забелязали, колко бързо и грозно набъбва методът play, където се въвежда команда от конзолата и след
това се проверява с поредица от if-ове коя точно команда е въведена.В тази задача ще направим, така че командите
да са отделени, лесно четими ииии да не са ни необходими толкова много if-ове, за да определим какво точно 
като команда е въвел потребителя.

Имаме интерфейс Command, той е функционален и метода, който притежава е void execute(Object… args).

Имаме enum ConsoleCommands, където константите ще са командите, които потребителя може да въвежда. 

Тези константи ще имат две полета. Първото ще е от тип String който ще показва какво очакваме да въведе 
потребителя, за да се изпълни командата (но без аргументите ѝ, само думата) 

Второто ще е от тип Command. Ще направим конструктор с аргументи и гетъри за полетата. Ще дефинираме константите
като за всяка от тях ще извикаме конструктора дефинирайки командата като ключова дума и като функционалност с 
ламбда израз. Поради факта, че за всички команди ще ни трябва селектираният обект, ще го направим публичен или
ще му направим статичен гетър с който да го достъпим. За някои команди ще ни трябва и списъка с единици на
картата за игра, него също трябва да го направим достъпен. Двете неща се намират в класа Game.

След като създадете всички константи и имплементирате командите (всъщност командите би трябвало да ги имате, 
така че няма да отнеме много време) ще трябва да модифицирате метода play в класа Game, така че след като се 
въведе команда да се изциклят всичките константи от ConsoleCommands и да се намери подходящата и да се execute.


Задача 5. 

Днес малко ще преработим кода. Това се налага поради простата причина че трябва да има повече от един играч и да
не може всеки да пипа единиците и градовете на всеки. Играчите трябва да се редуват, като се сменят на 
ротационен принцип веднага след като този който е на ред е въвел командата end turn.

Даден играч може:
-да вижда всички единици и градове на картата, независимо дали са негови или на противников играч
-да селектира само свои градове и  единици
-да извършва действия само със свои градове и единици

Даден играч има:
- име 
- списък с градовете
- списък с единиците
- селектираната в момента единица

Освен това, тъй като всеки играч всъщност представлява цяла цивилизация(множество от градове и единици), 
то тази цивилизация развива наука. Благодарение на науката се откриват нови технологии, които позволяват 
цивилизацията да напредва в развитието си, градовете да строят нови сгради, да създават нови единици. 
Например когато се открие the wheel можете да си правите армия с колесници, която е много по силна от пехотата.
Новите технологии не могат да се откриват хаотично, а всяка има една или повече предишни технологии, 
които трябва да са вече открити, за да може да се стартира процеса на откриване на новата. Затова е добре 
всяка да пази необходимите за откриването ѝ технологии в някакъв списък. 

Трябва освен това да пази и точки наука, които са необходими за откриването ѝ. 

Всеки играч има точки наука за ход, както и сборът им в текущия момент. Освен това разбира се пази и 
технологията, която се открива в дадения момент от време. Точките наука за ход се получават, 
като се вземе сборът от точките наука от всички градове на играча.

Искаме също така когато нова технология бъде открита или в даден град е построил някой юнит или сграда играчът 
да се известява в началото на следващия си ход за това. Ако е открита нова технология може да се извежда списък
с технологиите, които на този етап от играта могат да бъдат открити. Да се подкани играчът да въведе командата
за откриване на нова технология. Тази подкана да се извежда винаги когато играчът не е селектирал технология, 
която в дадения момент от време да се открива.

По даденото описание преработете досегашната имплементация и реализирайте новите класове така че програмата да 
постигне описаните по-горе характеристики!


Задача 6. Искаме да разширим командите и функционалността на нашата игра. Новата команда ще кара нашия 
MoveableUnit да замръзва и да седи замръзнал докато не бъде селектиран отново. Досадно е всеки път да пишем 
командата за селектиране при желание дадена единица да направи ход или да извърши някаква работа и за да си 
спестим това ще си направим SelectionManager клас който ще има метод, който автоматично ще сетва селекцията 
върху единица, която още не е изиграла хода си, но ще пропуска “замразените” единици. 

В класа MoveableUnit си добавете булево поле freezed и напишете сетър и гетър за него, сетъра, освен нещата, 
които трябва да свърши по подразбиране, трябва и да премахва селекцията от даден юнит ако е замразен.

Направете клас SelectionManager, който има единствен статичен метод nextUnit, който да приема за аргумент 
Player и да връща следващата единица на този играч, която не е замразена и още не е карала хода си. 
За реализацията на тази функционалност използвайте Stream API. Ако такава единица няма, методът да връща null.
Използвайте този метод така че след всяка команда за движение да се селектира следващата на ред единица на 
играча, както и когато започва хода му да има една селектирана единица.

Добавете в списъка от възможни команди, командата freeze, и ѝ дайте функционалност такава, че да извършва 
гореописаните действия.